<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>綠茶如是说</title><link href="http://vc2tea.com/" rel="alternate"></link><link href="http://vc2tea.com/feeds/all.atom.xml" rel="self"></link><id>http://vc2tea.com/</id><updated>2014-09-22T10:33:00+08:00</updated><entry><title>写给非专业人士看的 Shadowsocks 简介</title><link href="http://vc2tea.com/whats-shadowsocks/" rel="alternate"></link><updated>2014-09-22T10:33:00+08:00</updated><author><name>綠茶</name></author><id>tag:vc2tea.com,2014-09-22:whats-shadowsocks/</id><summary type="html">&lt;p&gt;这个文章来源于一个朋友在科学上网的过程中，搞不清楚 Shadowsocks 的配置问题，在这里我想按照我对 Shadowsocks 的理解简单梳理一下，以便一些非专业人士也能了解&lt;/p&gt;
&lt;h3&gt;long long ago...&lt;/h3&gt;
&lt;p&gt;在很久很久以前，我们访问各种网站都是简单而直接的，用户的请求通过互联网发送到服务提供方，服务提供方直接将信息反馈给用户
&lt;img alt="ss-01" src="/static/images/whats-shadowsocks-01.png" /&gt;&lt;/p&gt;
&lt;h3&gt;when evil comes&lt;/h3&gt;
&lt;p&gt;然后有一天，&lt;a href="http://zh.wikipedia.org/wiki/%E9%87%91%E7%9B%BE%E5%B7%A5%E7%A8%8B"&gt;GFW&lt;/a&gt; 就出现了，他像一个收过路费的强盗一样夹在了在用户和服务之间，每当用户需要获取信息，都经过了 GFW，GFW将它不喜欢的内容统统过滤掉，于是客户当触发 GFW 的过滤规则的时候，就会收到 &lt;code&gt;Connection Reset&lt;/code&gt; 这样的响应内容，而无法接收到正常的内容
&lt;img alt="ss-02" src="/static/images/whats-shadowsocks-02.png" /&gt;&lt;/p&gt;
&lt;h3&gt;ssh tunnel&lt;/h3&gt;
&lt;p&gt;聪明的人们想到了利用境外服务器代理的方法来绕过 GFW 的过滤，其中包含了各种HTTP代理服务、Socks服务、VPN服务... 其中以 ssh tunnel 的方法比较有代表性&lt;/p&gt;
&lt;p&gt;1) 首先用户和境外服务器基于 ssh 建立起一条加密的通道
2-3) 用户通过建立起的隧道进行代理，通过 ssh server 向真实的服务发起请求
4-5) 服务通过 ssh server，再通过创建好的隧道返回给用户&lt;/p&gt;
&lt;p&gt;&lt;img alt="ss-03" src="/static/images/whats-shadowsocks-03.png" /&gt;&lt;/p&gt;
&lt;p&gt;由于 ssh 本身就是基于 RSA 加密技术，所以 GFW 无法从数据传输的过程中的加密数据内容进行关键词分析，避免了被重置链接的问题，但由于创建隧道和数据传输的过程中，ssh 本身的特征是明显的，所以 GFW 一度通过分析连接的特征进行干扰，导致 ssh
存在被定向进行干扰的问题&lt;/p&gt;
&lt;h3&gt;shadowsocks&lt;/h3&gt;
&lt;p&gt;于是 &lt;a href="https://github.com/clowwindy/shadowsocks"&gt;clowwindy&lt;/a&gt; 同学分享并开源了他的&lt;a href="http://www.v2ex.com/t/32777"&gt;解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单理解的话，shadowsocks 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端，所以下面这个原理图基本上和利用 ssh tunnel 大致类似&lt;/p&gt;
&lt;p&gt;1、6) 客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯，由于这个 ss-local 一般是本机或路由器或局域网的其他机器，不经过 GFW，所以解决了上面被 GFW 通过特征分析进行干扰的问题
2、5) ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯，经过 GFW 的时候是常规的TCP包，没有明显的特征码而且 GFW 也无法对通讯数据进行解密
3、4) ss-server 将收到的加密数据进行解密，还原原来的请求，再发送到用户需要访问的服务，获取响应原路返回
&lt;img alt="ss-04" src="/static/images/whats-shadowsocks-04.png" /&gt;&lt;/p&gt;</summary><category term="shadowsocks"></category><category term="gfw"></category></entry><entry><title>用 Redis 缓存静态文件</title><link href="http://vc2tea.com/redis-static-file-cache/" rel="alternate"></link><updated>2014-09-07T00:46:00+08:00</updated><author><name>綠茶</name></author><id>tag:vc2tea.com,2014-09-07:redis-static-file-cache/</id><summary type="html">&lt;p&gt;一般网站为了缓解服务器的资源消耗，会将一些包含动态内容并且访问量特别大的页面（比如首页），采用静态化的手段来进行优化。&lt;/p&gt;
&lt;p&gt;最传统的做法就是通过定期执行的后台进程，将动态内容抓取出来，生成一个 html / inc 文件存放在文件系统中，然后在首页中用各种语言的 include 语法将静态的内容包含进去。&lt;/p&gt;
&lt;p&gt;这种做法存在以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;include 静态文件，一旦文件不存在，页面往往会直接报错&lt;/li&gt;
&lt;li&gt;随着网站的发展，这些生成的小文件可能会越来越多，同时旧的小文件也可以有些直接被废弃掉了，管理这些小文件难度大&lt;/li&gt;
&lt;li&gt;当服务器不只一台的情况下，这些小文件还需要考虑实时同步的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;没错，还是利用 Redis，聪明的朋友可能一下子就能想到为什么了，不过还是让我详细再说明下吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;还是采用后台程序将动态的内容静态化，但是这次静态化的目标不是生成静态文件，而是将静态文件的内容保存在 Redis 中&lt;/li&gt;
&lt;li&gt;给生成的 Redis 内容加上一个合理的生存期，比如这个静态内容是每天生成的，可以设置生存期为5天，如果这个内容确实是活的话，那进程会一直保证这个内容是存在的，一旦进程被废弃掉了，内容在5天后也会自动被清理掉，无需人工干预&lt;/li&gt;
&lt;li&gt;页面中不再采用 include 的方式，而是直接读取对应 Redis 的内容并拼接在原页面内容中，当 Redis 的内容不存在时返回空字符串，这样页面最多只会留空没有内容的位置，而不会导致整个页面报错&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然这样直接就解决了服务器文件同步的问题了，并且由于是基于内存读取，比起读取文件IO的效率又进一步提升了。&lt;/p&gt;</summary><category term="redis"></category><category term="cache"></category></entry><entry><title>用 Redis 实现互斥锁</title><link href="http://vc2tea.com/redis-mutex/" rel="alternate"></link><updated>2014-09-03T07:46:00+08:00</updated><author><name>綠茶</name></author><id>tag:vc2tea.com,2014-09-03:redis-mutex/</id><summary type="html">&lt;p&gt;在&lt;a href="http://zh.wikipedia.org/wiki/多线程"&gt;多线程&lt;/a&gt;执行的程序下，无可避免的会遇到资源竞争的问题，为了解决资源竞争的问题，引入&lt;a href="http://zh.wikipedia.org/wiki/互斥锁"&gt;互斥锁&lt;/a&gt;应该是公认的解决方案吧，而 Redis 的特性（基于内存，有生存期）我觉得非常适合用来实现互斥锁。&lt;/p&gt;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;我遇到的问题是在对 &lt;a href="https://lucene.apache.org"&gt;Lucene&lt;/a&gt; 更新索引的时候，原来采取的策略是将某个数据表增量的数据通过一个线程定期去更新和 flush 索引文件，但由于业务的扩展，原来的业务变成了从2个不同的数据表用2个不同的定期线程去更新。&lt;/p&gt;
&lt;p&gt;这个时候问题来了，在 flush 到文件系统中的时候，虽然 Lucene 本身创建了一个 &lt;code&gt;write.lock&lt;/code&gt; 来避免文件冲突，但是由于线程中运行的程序在 flush 过程中可能因为异常导致线程直接中断，导致 &lt;code&gt;write.lock&lt;/code&gt; 文件没有被及时清除和处理，后续的索引更新线程全部作废。&lt;/p&gt;
&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;虽然原则上这应该是线程异常处理范畴的问题，不过同时存在下面这2个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write.lock&lt;/code&gt; 文件没有被及时释放&lt;/li&gt;
&lt;li&gt;如果使用程序全局变量的锁又无法很好地管理和监测&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而利用 Redis 的特性去实现互斥锁可以很好地解决这2个问题，原理非常简单&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要加锁的时候，生成一个 lock_key，expire time 设置为估计该线程执行大概的时间，内容可以是空也可以将是哪个线程或什么时候产生的信息放到内容中&lt;/li&gt;
&lt;li&gt;锁的判定，判定上面生成的 lock_key 是否存在&lt;/li&gt;
&lt;li&gt;线程资源竞争的部分执行完后， del lock_key 释放资源&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样一来，由于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Key 是有生存期的，即使线程挂掉没有及时释放，但锁在一定时限内还是会自动释放，不影响后续竞争该资源的线程的执行&lt;/li&gt;
&lt;li&gt;锁的状态可以通过 Redis 的管理工具及时监控得到&lt;/li&gt;
&lt;li&gt;Redis 基于内存，读写效率都很快&lt;/li&gt;
&lt;li&gt;Redis 本身就是单线程模型的实现，比手动在程序中实现单例的锁更简洁&lt;/li&gt;
&lt;/ul&gt;</summary><category term="redis"></category><category term="mutex"></category></entry><entry><title>用 Redis 模拟 session</title><link href="http://vc2tea.com/redis-session/" rel="alternate"></link><updated>2014-09-01T00:07:00+08:00</updated><author><name>綠茶</name></author><id>tag:vc2tea.com,2014-09-01:redis-session/</id><summary type="html">&lt;p&gt;&lt;a href="http://redis.io/"&gt;Redis&lt;/a&gt; 是一个强大而简单的键值型数据库，之前在公司网站改版的过程中大量使用 Redis 来处理一些特殊的需求，我希望能将自己对 Redis 的使用经验都分享出来，而这里算是第一篇吧。&lt;/p&gt;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;项目是一个有着不小访问量的网站，为了达到分流的作用，网站按照不同的业务（个人、企业、后台、营销、搜索、API等）区分成不同的子域名，而子域名下运行的是不同的实例。&lt;/p&gt;
&lt;p&gt;对用户登录这块的逻辑，原来的做法是将登录的明文信息（登录ID、用户名、姓名等）在登录过程中直接写入用户 cookie，当需要进行登录校验的时候，后台直接取出 cookie 中保存的ID进行处理。可以想象，这样的模式只要模拟或者盗取了客户端的 cookie 信息，对于客户来说几乎没有任何安全性的保障。&lt;/p&gt;
&lt;p&gt;由于用户的操作可能跨越多个实例，如果采用服务器 session 的机制的话，就需要解决 session 的共享问题，从技术的实现角度来说可能碰到的坑就更多了，于是我们利用了 Redis 来模拟服务器的 session。&lt;/p&gt;
&lt;h3&gt;实际设计&lt;/h3&gt;
&lt;p&gt;&lt;img alt="图1" src="/static/images/redis-session-01.png" /&gt;&lt;/p&gt;
&lt;p&gt;登录流程见图1&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户从浏览器中将登录信息传到 Web Server 中处理&lt;/li&gt;
&lt;li&gt;Web Server 首先跟进行用户信息验证，当验证通过的时候，根据用户的客户端信息（IP、浏览器信息等）进行散列，形成一个 token，这个 token 将会是 Redis 中的 Key，同时将经常需要获取的内容（用户ID、姓名等）组装成 Value，根据需要可以是 json 格式或者 HashTable，然后设定一个 expire time 保存进 Redis&lt;/li&gt;
&lt;li&gt;将生成的 token 保存在用户的浏览器 cookie 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="图2" src="/static/images/redis-session-02.png" /&gt;&lt;/p&gt;
&lt;p&gt;验证流程见图2&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户访问需要进行验证登录的内容时，客户端会将 cookie 传到 Web Server 中&lt;/li&gt;
&lt;li&gt;Web Server 从 cookie 中获取到 token 的值，判断 token 是否存在于 Redis 中&lt;/li&gt;
&lt;li&gt;若存在则将 Redis 中保存的信息返回到 Web Server 中进行处理，判断此次获取是否合法：&lt;ul&gt;
&lt;li&gt;客户端的信息是否和生成 token 时的一致（IP、浏览器信息等）&lt;/li&gt;
&lt;li&gt;Value 中保存的内容是否和当前操作匹配（用户ID是否和当前处理的ID，或者如果将IP等信息放到内容中也可以将上一条的验证在这里处理）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有验证通过则将正常的结果返回给用户，有需要的话还可以在这个过程中重置或延长原来 Redis key 的生存时间&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;这样做解决了什么问题？&lt;/h3&gt;
&lt;p&gt;其实这是一个很简单的思路，将客户登录验证和客户信息获取这两部分内容合并到 Redis 中来进行处理了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不利用服务器的 session，这样当多服务器部署的时候就不需要关心 session 的同步问题了&lt;/li&gt;
&lt;li&gt;客户端 cookie 中保存的 token 信息是散列后的内容，不涉及任何业务属性，cookie 一旦被抓取到了单纯从 cookie 信息中也不会丢失任何敏感数据&lt;/li&gt;
&lt;li&gt;token 即使被盗用了并被有意进行模仿，如果不是完全按照客户登录时的IP、浏览器信息来进行模拟的话，基本无法获取到客户的信息&lt;/li&gt;
&lt;li&gt;常用的信息保存在 Redis 中，由于直接读取了内存，比起持久化的数据库查询，读取速度快了很多，减少了负载同时提升了访问效率&lt;/li&gt;
&lt;li&gt;Redis 中的内容设定了生存时间，当有效期内执行操作重置时间这样的机制模拟了 session timeout，这样也能进一步保证用户的数据安全性&lt;/li&gt;
&lt;/ul&gt;</summary><category term="redis"></category><category term="session"></category><category term="security"></category></entry><entry><title>Django 项目维护记</title><link href="http://vc2tea.com/django-maintain/" rel="alternate"></link><updated>2014-08-14T00:36:00+08:00</updated><author><name>綠茶</name></author><id>tag:vc2tea.com,2014-08-14:django-maintain/</id><summary type="html">&lt;p&gt;近来由于工作需要，所以需要接手几个用 &lt;a href="https://www.djangoproject.com"&gt;Django&lt;/a&gt; 编写的网站项目，虽然一直对 &lt;a href="https://www.python.org/"&gt;Python&lt;/a&gt; 有好感，但毕竟作为工作上的项目还是真正的第一次接触，其中遇到了一些问题总算花了几天的时间搞清楚了，在此分享一下&lt;/p&gt;
&lt;h3&gt;pip 和 virtualenv&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://pip.pypa.io/en/latest/"&gt;pip&lt;/a&gt; 已经作为 Python 的标准包管理工具了，安装自不用说，这里说一下全局配置中的 download cache，创建 &lt;code&gt;~/.pip/pip.conf&lt;/code&gt; 文件，内容为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[global]&lt;/span&gt;
&lt;span class="na"&gt;download-cache&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;~/.pip/cache&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就能在使用 &lt;code&gt;pip install&lt;/code&gt; 的时候将下载回来的文件缓存起来了，由于我维护的多个系统使用类似的包，这样就省得每次创建新环境的时候重新去下载了&lt;/p&gt;
&lt;p&gt;&lt;a href="http://virtualenv.readthedocs.org/en/latest/"&gt;virtualenv&lt;/a&gt; 也是大名鼎鼎的虚拟环境工具了，在同一台机器上运行多个环境，为了避免第三方包的冲突，将第三方包的环境隔离出来管理更方便，用处基本上是这几个&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;~/.virtualenvs/virtualenv env_name
source ~/.virtualenvs/env_name/bin/activate
deactivate
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Pillow&lt;/h3&gt;
&lt;p&gt;项目中用到的 &lt;a href="https://pillow.readthedocs.org/en/latest/"&gt;Pillow&lt;/a&gt; 是替代 PIL 的图片处理工具，在使用过程中发现2个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我在使用的 debian 7.4 安装 Pillow 过程中遇到 &lt;code&gt;compile error&lt;/code&gt; 的问题，需要在安装前保证 &lt;code&gt;sudo apt-get install python-dev python-imaging&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pillow 在实际运行中如果无法正常处理 JPEG 图片，后台会报 &lt;code&gt;decode JPEG&lt;/code&gt; 之类的错误提示，需要先将 Pillow 删除掉，安装 &lt;code&gt;sudo apt-get install libjpeg8-dev&lt;/code&gt; 后再重新 install Pillow&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;nginx + uwsgi&lt;/h3&gt;
&lt;p&gt;正式环境上的 Django 肯定是不能用 manage.py runserver 的方法去运行的，所以通过通用接口部署到主流的 web server 中是比较合理的方法，本来按照原项目是用 fastcgi + lighttpd 的模式，但折腾了好久都没成，最后用 nginx + uwsgi 的模式终于弄好了&lt;/p&gt;
&lt;p&gt;目前用的 uwsgi.ini 文件内容如下，由于目前维护的项目代码不是很规范的 Django 项目结构，也没有 wsgi.py 文件，所以 module 中设置为 django 默认的设置，利用了 /tmp/proj.sock 创建 socket 接口提供给 nginx 调用&lt;/p&gt;
&lt;p&gt;最后一个 pythonpath 是发现通过 uwsgi 模式运行起来后居然部分包无法识别，通过打开 debug，最后发现 pythonpath 中缺少这个目录导致的，于是在 uwsgi 配置文件中将这个 pythonpath 手动指定一下，所以建议各位在运行成功前还是打开 debug 模式，以便确实跟踪问题所在&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[uwsgi]&lt;/span&gt;
&lt;span class="na"&gt;project-name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;proj&lt;/span&gt;

&lt;span class="na"&gt;chdir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;~/projects/%(project-name)/code&lt;/span&gt;
&lt;span class="na"&gt;env&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;DJANGO_SETTINGS_MODULE=%(project-name).settings&lt;/span&gt;
&lt;span class="na"&gt;virtualenv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;~/.virtualenvs/%(project-name)&lt;/span&gt;
&lt;span class="na"&gt;module&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;django.core.handlers.wsgi:WSGIHandler()&lt;/span&gt;
&lt;span class="na"&gt;master&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;True&lt;/span&gt;
&lt;span class="na"&gt;pidfile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/tmp/%(project-name).pid&lt;/span&gt;
&lt;span class="na"&gt;socket&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/tmp/%(project-name).sock&lt;/span&gt;
&lt;span class="na"&gt;vacuum&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;True&lt;/span&gt;
&lt;span class="na"&gt;max-requests&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;100&lt;/span&gt;
&lt;span class="na"&gt;daemonize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/tmp/%(project-name).log&lt;/span&gt;
&lt;span class="na"&gt;pythonpath&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;~/projects/%(project-name)/code/%(project-name)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行的方法是 &lt;code&gt;uwsgi --ini uwsgi.ini&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而 nginx 的配置就比较简单了，在 uwsgi_pass 中设置为刚才指定的 sock 文件就可以了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;listen&lt;/span&gt;   &lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;server_name&lt;/span&gt; &lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;uwsgi_pass&lt;/span&gt; &lt;span class="n"&gt;unix&lt;/span&gt;&lt;span class="o"&gt;:///&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;proj&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;include&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;nginx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uwsgi_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;还有其他的一些&lt;/span&gt; &lt;span class="nt"&gt;static&lt;/span&gt; &lt;span class="nt"&gt;的配置&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;静态文件无法加载&lt;/h3&gt;
&lt;p&gt;部署上 nginx 后，关闭 settings 中的 debug，部分样式脚本等静态文件可能会无法加载，这个时候要注意2点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;debug 关闭后，静态文件是通过 nginx 读取的，关闭前是直接重定向到 python 的第三方包中，所以需要用 &lt;code&gt;python manage.py collectstatic&lt;/code&gt; 将使用到的第三方静态文件自动拷贝下来，当然为了效率 nginx 上也要做相应的配置&lt;/li&gt;
&lt;li&gt;生成的 static 目录是否有读取权限？由于设置给 nginx 代理静态文件，所以起码 nginx 用户需要有对 static 及子目录有读取权限，chmod 处理一下&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;网站无法打开&lt;/h3&gt;
&lt;p&gt;这也是第一次处理 Django 没有注意到的地方，正式部署后只能通过 settings 中 &lt;code&gt;ALLOWED_HOSTS&lt;/code&gt; 配置的域名才能访问，修改一下配置或在要访问的客户机中在调整一下 hosts 即可&lt;/p&gt;</summary><category term="django"></category><category term="python"></category><category term="uwsgi"></category><category term="nginx"></category><category term="pip"></category><category term="virtualenv"></category><category term="pillow"></category></entry><entry><title>Ghost Blogging</title><link href="http://vc2tea.com/ghost-blogging/" rel="alternate"></link><updated>2014-08-11T18:28:00+08:00</updated><author><name>綠茶</name></author><id>tag:vc2tea.com,2014-08-11:ghost-blogging/</id><summary type="html">&lt;p&gt;&lt;a href="http://docs.ghost.org/"&gt;Ghost&lt;/a&gt; 是基于 &lt;a href="http://nodejs.org/"&gt;Node.js&lt;/a&gt; 的博客系统，这个博客就是利用 Ghost 搭建的，详细的介绍就不写了，下面记录下相关的流程，算是备忘&lt;/p&gt;
&lt;p&gt;首先肯定是安装 Node.js 环境，由于我用的是 debian 7.5，所以将 Node.js 的 source list 加进来并安装，当然还有 sqlite 3&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;curl -sL https://deb.nodesource.com/setup | sudo bash -
apt-get install nodejs
apt-get install sqlite3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来就是从 ghost 官网下载最新的压缩包并解压，通过 &lt;code&gt;npm install --production&lt;/code&gt; 来安装了，但是这个过程中遇到 debian 的 &lt;code&gt;glib&lt;/code&gt; 版本问题，通过安装 tesing 的 &lt;code&gt;libc6-dev&lt;/code&gt; 解决&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;echo &amp;#39;deb http://ftp.debian.org/debian testing main&amp;#39; | sudo tee -a /etc/apt/sources.list
sudo apt-get update
sudo apt-get -t testing install libc6-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个时候基本就完工了，修改下 &lt;code&gt;config.js&lt;/code&gt; 就可以用 &lt;code&gt;npm start --production&lt;/code&gt; 来启动了&lt;/p&gt;
&lt;p&gt;当然如果是需要作为 deamon 来运行的，要用 &lt;code&gt;forever&lt;/code&gt; 或 &lt;code&gt;pm2&lt;/code&gt; 这样的工具来执行，我用的是 &lt;code&gt;pm2&lt;/code&gt; ，安装 &lt;code&gt;npm install -g pm2&lt;/code&gt; ，运行的话使用 &lt;code&gt;NODE_ENV=production pm2 start index.js --name ghost&lt;/code&gt; ，这样就可以在 daemon 的情况下启动了&lt;/p&gt;
&lt;p&gt;我们一般还习惯用 &lt;code&gt;nginx&lt;/code&gt; 来做反向代理的，所以安装一下，我默认安装的版本是 1.6.0 ，当然 其他版本的配置也是大同小异，在 &lt;code&gt;/etc/nginx/conf.d/&lt;/code&gt; 下面创建一个 &lt;code&gt;ghost.conf&lt;/code&gt; 文件之类的，加上反向代理的配置就可以了，最简单的配置类似这样的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;listen&lt;/span&gt;       &lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;server_name&lt;/span&gt;  &lt;span class="n"&gt;vc2tea&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#这里是域名设置&lt;/span&gt;

    &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;proxy_pass&lt;/span&gt;   &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;://&lt;/span&gt;&lt;span class="m"&gt;127&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="m"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#改成&lt;/span&gt; &lt;span class="n"&gt;ghost&lt;/span&gt; &lt;span class="err"&gt;的端口号&lt;/span&gt;

        &lt;span class="n"&gt;proxy_redirect&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;proxy_set_header&lt;/span&gt; &lt;span class="n"&gt;Host&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;proxy_set_header&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Real&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;IP&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;remote_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;proxy_set_header&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Forwarded&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;For&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;proxy_add_x_forwarded_for&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then , enjoy yourself !&lt;/p&gt;</summary><category term="ghost"></category><category term="nginx"></category><category term="nodejs"></category></entry><entry><title>綠茶，你还想说什么？</title><link href="http://vc2tea.com/first/" rel="alternate"></link><updated>2014-08-10T00:14:00+08:00</updated><author><name>綠茶</name></author><id>tag:vc2tea.com,2014-08-10:first/</id><summary type="html">&lt;p&gt;重新开 Blog，按照惯例，免不了有些碎碎念，姑且记录下来吧。&lt;/p&gt;
&lt;p&gt;算了一下这已经是纯属个人胡言乱语的第4个 Blog 了，她的前辈们到底经历了一些什么东西呢，让我再好好回想一下黑历史&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;06-07年，正值毕业季的当时写博客大概是一种潮流吧，于是在 Blogcn 上也凑了下热闹，记录下毕业的青涩和刚入职场的点点滴滴，可惜 Blogcn 历经多次变更，最原始的这些内容早已经不存在于比特世界了吧&lt;/li&gt;
&lt;li&gt;07年中，由于对 Google 图腾的信仰，将阵地迁移到 Blogspot 去了，可惜由于07年的 GFW 开始肆虐，更多的内容是关于互联网上各种优秀的东西封与被封的记录和吐槽，从此对 GFW 深恶痛绝... 除此以外大概就是一些动画的点评和分享，于是「一入宅门深似海，从此节操是路人了」... &lt;/li&gt;
&lt;li&gt;08-09年，玩心又被当时流行的 Wordpress 吸引住了，于是在 HostMonster 买了个便宜的虚拟主机，踏上了各种折腾的旅程，这个时期各种碎碎念都会写一篇东西记录下来，用现在的词汇来说这段时间就是装逼＋文艺逼＋二逼的混合体吧，一直到最后一篇，关于在鼓浪屿上将婚纱照拍完的记录文后，所有的碎碎念都已经交给 Twitter 了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;岁月如梭，流光亦如白驹过隙，转眼间已经身为人父，工作也早已从繁嚣喧闹的广州回到东莞了，面对这个纷扰的世界，我还想说些什么呢？这个问题大概自己也想不清楚，「于是只要去做就可以了」 —— 大师们如此告诫着我...&lt;/p&gt;
&lt;p&gt;好吧，那就做吧，不管什么东西，只要用心去做，努力地向前走，一定会找到答案的吧。&lt;/p&gt;</summary></entry></feed>